<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>拖拽对齐参考线的实现</title>
    <link href="/blog/2020/12/21/align-guides/"/>
    <url>/blog/2020/12/21/align-guides/</url>
    
    <content type="html"><![CDATA[<h1 id="拖拽对齐参考线实现"><a href="#拖拽对齐参考线实现" class="headerlink" title="拖拽对齐参考线实现"></a>拖拽对齐参考线实现</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p> &nbsp;&nbsp;&nbsp;&nbsp;说到拖拽，我们并不陌生，比如我们平常用的拖拽排序；拖拽上传文件；拖拽对齐等…其中就有我今天要说到的拖拽对齐。那么拖拽对齐到底是怎么一回事？我们又该如何实现这个功能呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，我们先来看看拖拽对齐的效果的怎么样的，我们以一个在线画图工具ProcessOn来展示，如下图所示：</p><p><img src="../assert/align-guides/show.gif" alt="拖拽对齐"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的动图我们可以很容易地理解这个功能的效果。就是我们在拖拽一个元素的时候，当这个拖拽元素与另外的元素的边界在水平方向或者竖直方向的位置一样时，就在这个方向上画一条对齐线。所以按照着这个思路，我们来模仿着这个效果实现一个我们自己的拖拽对齐参考线的效果吧！</p><h3 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2. 实现步骤"></a>2. 实现步骤</h3><p>​     如果将这个效果划分为多个步骤，简单来说那么我们可以分为如下的几个步骤：</p><ol><li>拖拽一个DOM元素，让这个DOM元素跟随我们鼠标的位置来移动</li><li> 记录我们要与拖拽元素对比的其他所有元素的边界的位置</li><li> 用这些记录的边界位置和我们拖拽时，拖拽元素的实时的边界位置做对比，如果相等则在该方向上画一条参考线</li><li> 放开鼠标，将拖拽DOM元素放到当前的位置</li></ol><h3 id="3-如何随心所欲拖拽DOM？"><a href="#3-如何随心所欲拖拽DOM？" class="headerlink" title="3. 如何随心所欲拖拽DOM？"></a>3. 如何随心所欲拖拽DOM？</h3><p>​     无论你用vue还是react技术框架，在github或者npm上都能搜到很多优秀的与拖拽相关的包，比如vue框架下的  <a href="https://www.npmjs.com/package/vue-dragable">vue-dragable</a> 或者 <a href="https://www.npmjs.com/package/vue-draggable-resizable">vue-draggable-resizable</a>等。它们都有很好的拖拽效果，可以通过简单的配置就可以实现拖拽排序，拖拽更改尺寸等功能。但我今天要讲的是基于HTML5的原生的拖拽的一些技巧，以及在平时的拖拽应用场景下我们会遇到什么难题，还有就是我们如何解决这些难题？</p><p>​    首先我们来学习一下拖拽的基本知识，我们可以把拖拽的整个元素由两部分组成。一是拖拽的元素，二是落点的元素。而按拖拽的流程来看，拖拽其实分为了三个部分： 选中  —&gt;  拖动  —&gt; 释放 。</p><p><strong>1. 选中：</strong></p><p>在HTML5标准中，为了使元素可拖动，把draggable属性设置为true。文本、图片和链接是默认可以拖放的，它们的draggable属性自动被设置成了true。</p><p><code>Tip: 图片和链接按住鼠标左键选中，就可以拖放。文本只有在被选中的情况下才能拖放。如果显示设置文本的draggable属性为true，按住鼠标左键也可以直接拖放。</code></p><p>draggable属性：设置元素是否可拖动。<br>语法：</p>  <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true | false | auto&quot;</span> &gt;</span></code></pre><ul><li>true: 可以拖动</li><li>false: 禁止拖动</li><li>auto: 跟随浏览器定义是否可以拖动</li></ul><p><strong>2.拖动：</strong></p><p>每一个可拖动的元素，在拖动过程中，都会经历三个过程，<code>拖动开始</code>–&gt;<code>拖动过程中</code>–&gt; <code>拖动结束</code>。</p><table><thead><tr><th align="center">对象</th><th align="left">事件名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">被拖动的元素</td><td align="left">dragstart</td><td align="center">在元素开始被拖动时候触发</td></tr><tr><td align="center"></td><td align="left">drag</td><td align="center">在元素被拖动时反复触发</td></tr><tr><td align="center"></td><td align="left">dragend</td><td align="center">在拖动操作完成时触发</td></tr><tr><td align="center"></td><td align="left"></td><td align="center"></td></tr><tr><td align="center">目的地对象</td><td align="left">dragenter</td><td align="center">当被拖动元素进入目的地元素所占据的屏幕空间时触发</td></tr><tr><td align="center"></td><td align="left">dragover</td><td align="center">当被拖动元素在目的地元素内时触发</td></tr><tr><td align="center"></td><td align="left">dragleave</td><td align="center">当被拖动元素没有放下就离开目的地元素时触发</td></tr></tbody></table><p><code>注意： dragenter和dragover事件的默认行为是拒绝接受任何被拖放的元素。因此，我们必须阻止浏览器这种默认行为。e.preventDefault();</code></p><p><strong>3. 释放：</strong></p><p>到达目的地之后，释放元素事件</p><table><thead><tr><th align="center">对象</th><th align="left">事件名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">目的地对象</td><td align="left">drop</td><td align="center">当被拖动元素在目的地元素里放下时触发，一般需要取消浏览器的默认行为。</td></tr></tbody></table><p>​      以上就是整个拖拽过程相关的API了，那么可能有人要问了，如果在拖拽过程中我们需要存储一些数据进行拖拽过程中的交互，那这个如何呢？那就要用到DataTransfer对象登场了。</p><p><strong>DataTransfer：</strong></p><p>​      DataTransfer是与拖放操作所触发的事件同时派发的对象，它派生于MouseEvent，具有Event与MouseEvent对象的所有功能，并增加了dataTransfer属性。该属性用于保存拖放的数据和交互信息，返回DataTransfer对象。我们可以通过事件对象的<code>event.dataTransfer</code>来获取这个对象，这个对象包含的属性和方法如下图所示：</p><p><img src="../assert/align-guides/data-transfer.png" alt="datatransfer"></p><p>具体每一项属性或者方法的含义如下所示：</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/types">types</a></td><td align="left">只读属性。它返回一个我们在dragstart事件中设置的拖动数据格式的数组。 格式顺序与拖动操作中包含的数据顺序相同。IE10+、Edge、safari3.1、Firefox3.5+ 和Chrome4以上支持该属性</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/files">files</a></td><td align="left">返回拖动操作中的文件列表。包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/dropEffect">dropEffect</a></td><td align="left">获取当前选定的拖放操作的类型或将操作设置为新类型。它应该始终设置成effectAllowed的可能值之一【none、move、copy、link】。dragover事件处理程序中针对放置目标来设置dropEffect。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/effectAllowed">effectAllowed</a></td><td align="left">指定拖放操作所允许的效果。必须是其中之一【 none, copy, copyLink, copyMove, link, linkMove, move, all, uninitialized】默认为uninitialized 表示允许所有的效果。ondragstart处理程序中设置effectAllowed属性</td></tr></tbody></table><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/setData">void setData(format, data)</a></td><td align="left">将拖动操作的拖动数据设置为指定的数据和类型。format可以是MIME类型</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/getData">String getData(format)</a></td><td align="left">返回指定格式的数据，format与setData()中一致</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/clearData">void clearData(format)</a></td><td align="left">删除给定类型的拖动操作的数据。如果给定类型的数据不存在，此方法不执行任何操作。如果不给定参数，则删除所有类型的数据。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/setDragImage">void setDragImage(img, xOffset, yOffset)</a></td><td align="left">指定一副图像，当拖动发生时，显示在光标下方。大多数情况下不用设置，因为被拖动的节点被创建成默认图片。x,y参数分别指示图像的水平、垂直偏移量</td></tr></tbody></table><p>​     如果你使用Vue的话完全可以使用Vuex来存储整个拖拽过程你需要的数据，使用React的话也同样可以使用Redux来存储，这样搭配起使用的框架来说也更加优雅一些。搞懂了上面的基础知识，我们就可以愉快的实现拖拽DOM了，But….下面这些问题，你在开发过程中可能也会遇到，举些栗子：</p><p><strong>关于拖拽你可能会遇到的难点：</strong></p><p>​    <strong>1.如何自定义拖拽拖影？</strong></p><p>​        什么叫拖拽拖影呢？其实很好理解，大家肯定也见过，如下图所示：</p><p>​         <img src="../assert/align-guides/drag-shadow.png" alt="拖拽阴影"></p><p>​     由上面的知识我们可以知道，图片默认都是可拖拽的，当图片被拖拽的时候，浏览器就会依据这个图片产生一个阴影，我们称之为“拖拽阴影”，是不是有一种灵魂出窍的感觉。但有时候我们不想要这种默认行为，我们想自定义自己的拖拽阴影，那么我们该如何去实现呢？</p><p>​     HTML5的拖拽API中为我们提供了这样一个方法叫做setDragImage，可以自定义拖拽过程中的拖影，它的具体用法如下所示：</p><p> <strong>语法：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">void</span> dataTransfer.setDragImage(img, xOffset, yOffset);</code></pre><p><strong>参数：</strong></p><ul><li><p><em>img |</em> Element</p><p>用于拖曳反馈图像的图像 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element"><code>Element</code></a> 元素。图像通常是一个<image>元素，但也可以是<canvas>或任何其他图像元素。</p></li><li><p><em>xOffset</em></p><p>图片相对于鼠标指针出现的x方向的偏移量</p></li><li><p><em>yOffset</em></p><p>图片相对于鼠标指针出现的y方向的偏移量</p></li></ul><p><strong>使用：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image();img.src = dragIcon;<span class="hljs-built_in">document</span>.body.appendChild(img); <span class="hljs-comment">// 必须把该元素添加到dom才能显示自定义拖拽阴影</span>evt.dataTransfer.setDragImage(img, -<span class="hljs-number">20</span>, <span class="hljs-number">120</span>);</code></pre><p><strong>注意： 如果插入的dom元素，比如<image>，放入setDragImage前请确保插入dom树中</strong></p><p>  <strong>2. 如果拖拽的时候拖拽元素或者拖拽元素父元素不渲染了，如何保证拖拽正常执行？</strong></p><p>​       有一种情况，当我们拖拽一个dom元素的时候，需要把拖拽面板隐藏，在Vue中我们通过对于这个面板通过v-if 或者 v-show 控制变量进行隐藏，我们拿阿里的imgcook来举个栗子：</p><p>​    <img src="../assert/align-guides/drag-hidden.gif" alt="拖拽隐藏"></p><p>​    从上面的动图中可以看到，当我们拖拽组件的时候，组件库面板隐藏了，漏出了组件树面板。如果按照我们上面的思路实现这个效果，拖拽的时候把父元素隐藏，那么这个拖拽的结果就是<strong>拖拽被打断</strong>。那么我们应该如何实现这一效果，又能不打断拖拽呢？</p><p>​    换另一个角度想，我们只是想拖拽的时候，让父元素还保持在DOM中渲染即可，即不会被移除DOM树或者不会被display:none；即可。那么我们这么做，制作一个空面板，然后我们把要拖拽的面板通过position: absolute;定位到这个空面板，当拖拽切换面板的时候，空面板隐藏，而我们的拖拽面板不隐藏而是瞬间移除视野之外，拖拽结束再让它回来。</p><pre><code class="hljs js"><span class="hljs-comment">// 拖拽的开始的时候</span> <span class="hljs-function"><span class="hljs-title">dragStart</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-built_in">this</span>.$refs.dragContainer.style = &#123;     opacity: <span class="hljs-number">0</span>,     left:-1000px   &#125; &#125;<span class="hljs-comment">// 拖拽结束的时候</span> <span class="hljs-function"><span class="hljs-title">dragEnd</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-built_in">this</span>.$refs.dragContainer.style = &#123;     opacity: <span class="hljs-number">1</span>,     left:80px   &#125; &#125;</code></pre><p>​     这样以来我们就巧妙地避开了拖拽被打断的情况，但当你以为这个是个好办法的时候，你会发现这样拖拽还是被打断了，为什么呢？因为你在拖拽的时候改变了容器的位置！没错，改变位置同样会打断拖拽！那…到底该如何实现这种拖拽效果呢？ 换另一个角度想，我们是因为拖拽开始的时候改变了样式导致拖拽被打断，那么我们等拖起来再改变样式呢？没错！我们可以把设置样式放在计时器setTimeOut中，等拖拽起来之后我们我们再改变样式，这样一来就可以完美实现该效果了!</p><pre><code class="hljs js"><span class="hljs-comment">// 拖拽的开始的时候</span> <span class="hljs-function"><span class="hljs-title">dragStart</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">this</span>.$refs.dragContainer.style = &#123;     opacity: <span class="hljs-number">0</span>,     left:-1000px   &#125;   &#125;,<span class="hljs-number">0</span>) &#125;</code></pre><h3 id="4-如何记录DOM元素的位置边界？"><a href="#4-如何记录DOM元素的位置边界？" class="headerlink" title="4.如何记录DOM元素的位置边界？"></a>4.如何记录DOM元素的位置边界？</h3><p>​    记录我们要拖拽元素的位置和要做对齐比较的元素的位置，对于实现对齐参考线来说至关重要。Web中有一个方法getBoundingClientRect，这个方法返回元素的大小及其相对于视口的位置，也就是clientX和clientY的这个视口。</p><p>​    <strong>使用：</strong></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> position = dom.getBoundingClientRect();<span class="hljs-keyword">const</span> &#123; left = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, bottom = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span> &#125; = position;<span class="hljs-comment">// left 元素相对于视口左边的距离</span><span class="hljs-comment">// top 元素相对于视口上边的距离</span><span class="hljs-comment">// right 元素相对于视口右边的距离</span><span class="hljs-comment">// bottom 元素相对于视口下边的距离</span><span class="hljs-comment">// width 元素的宽度</span><span class="hljs-comment">// height 元素的高度</span></code></pre><p><strong>注意： 如果是标准盒子模型，元素的宽或高等于<code>width/height</code> + <code>padding</code> + <code>border-width</code>的总和。如果<code>box-sizing: border-box</code>，元素的的尺寸等于 <code>width/height</code>。</strong></p><p>   这个API可以很方便地让我们记录我们想要监听元素的位置，而我们想要对比监听的元素我们可以给每个元素添加一个ref或者id又或者data-xx 自定义属性等。具体记录监听的元素可以参考如下代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> nodes = <span class="hljs-built_in">this</span>.root.querySelectorAll(<span class="hljs-built_in">this</span>.selector);<span class="hljs-keyword">if</span> (nodes &amp;&amp; nodes.length === <span class="hljs-number">0</span>) &#123;  <span class="hljs-keyword">return</span>;&#125;nodes.forEach(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;  node._leval = <span class="hljs-number">0</span>;  node._children = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([]);  node._id = node.getAttribute(<span class="hljs-built_in">this</span>.idAttr);&#125;);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nodes.length; i++) &#123;  <span class="hljs-keyword">const</span> position = nodes[i].getBoundingClientRect() || &#123;&#125;;  <span class="hljs-keyword">const</span> &#123; width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, bottom = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span> &#125; = position;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nodes.length; j++) &#123;    <span class="hljs-keyword">if</span> (nodes[i].contains(nodes[j])) &#123;      nodes[j]._leval += <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录元素的层级</span>      nodes[j]._parentId = nodes[i]._id; <span class="hljs-comment">// 记录父节点</span>      nodes[i]._children = nodes[i]._children.add(nodes[j]._id); <span class="hljs-comment">// 记录元素的子节点们</span>    &#125;  &#125;  <span class="hljs-built_in">this</span>.listeners.push(&#123;    id: nodes[i]._id,    width,    height,    top,    bottom,    left: <span class="hljs-built_in">Math</span>.round(left),    right: <span class="hljs-built_in">Math</span>.round(right),    leval: nodes[i]._leval,    parentId: nodes[i]._parentId,    children: nodes[i]._children  &#125;);&#125;</code></pre><p>   从上可以看出，如果选择器通过querySelectorAll来查找，是无法区分查找结果的具体父子关系的，而父子元素对于我们的拖拽对齐很有用，比如我们再拖拽一个元素，这个元素又包含着一些子元素，我们拖拽这个元素的时候，我们肯定是不希望它与内部的子元素还做对比，我们画的参考线是针对于其外部的其他元素做对比。因此我们可以通过 <code>dom1.contains(dom2)</code>来判断和记录它们的父子关系。然后我们在页面监听元素更新的时候，再去重新收集依赖最新的位置信息即可。</p><h3 id="5-如何实现靠近吸附？"><a href="#5-如何实现靠近吸附？" class="headerlink" title="5. 如何实现靠近吸附？"></a>5. 如何实现靠近吸附？</h3><p>​        由于我们在拖拽的时候，并非是1像素1像素地去移动地，而两个元素的对齐又是在一瞬间的，只有在某一边的位置完全相等的时候，我们才鞥称之为对齐，所以就有了靠近吸附的功能，它能帮助我们更容易地实现辅助对齐的效果。具体效果参考ProcessOn如下图所示：</p><p>  <img src="../assert/align-guides/show-align-line.gif"></p><p>可以看到当拖拽元素接近对齐元素的时候，有一个吸附的效果，然后在吸附的地方画了一个参考线，那么我们应该如何实现这种功能呢？</p><p>我们同样可以将这个功能拆解一下，大概满足如下的步骤就能实现：</p><ol><li>将方向分为x和y，且x和y方向的吸附是独立的</li><li>同一个方向上的同一时间最多只能有一个吸附效果</li><li>吸附效果应该出现在我们移动的方向上，比如向左移动的时候，吸附效果只能出现在x方向的左边的其他元素</li><li>当吸附发生后，应该有个鼠标安全距离，在这个安全距离内，鼠标的移动不会改变吸附效果，当大于这个距离的时候，才让拖拽元素跟着鼠标移动。不然会出现闪动或者“拔不出来”的情况。</li></ol><h3 id="6-如何画对齐参考线？"><a href="#6-如何画对齐参考线？" class="headerlink" title="6.如何画对齐参考线？"></a>6.如何画对齐参考线？</h3><p>   上面我们有了拖拽，也有了位置关系，那当拖拽元素与对比元素的位置一样的时候，如何画出一条对齐参考线呢？ 我们可以通过<canvas>元素来实现这一功能。</p><p>   要实现canvas绘图，首先我们要创建canvas然后将canvas元素绝对定位放到拖拽对齐展示区域的上面，那么另一个难题来了，canvas元素也是dom，也就是说它也会干扰鼠标事件，其中就包含着我们的拖拽事件。如果我们的落点的event.target为canvas了，那肯定不是我们想要的结果。所以如何让canvas执行画图功能，但又要让它“透明”不干扰鼠标事件呢？其实css中有个属性，叫做pointer-events，它代表着元素如何处理鼠标事件。当我们如下设置的时候，它就不会不会捕捉一切的鼠标事件，相当于存在但“透明”！</p>   <pre><code class="hljs css"><span class="hljs-selector-tag">pointer-event</span><span class="hljs-selector-pseudo">:none</span>;</code></pre><p>   canvas元素有了，然后我们再dragMove的时候可以实时地将拖拽元素和上面记录的对比监听者的边界做对比，如果相等就画一条线，下次执行dragMove的时候清除画布。伪代码如下：</p>   <pre><code class="hljs js"><span class="hljs-comment">// 生成canvas定位到展示区域上，并设置pointer-events:none;</span><span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;canvas&quot;</span>);<span class="hljs-keyword">const</span> &#123; width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span> &#125; = <span class="hljs-built_in">this</span>.rootPosition;canvas.width = width;canvas.height = height;canvas.style=<span class="hljs-string">`position:absolute;pointer-events:none;left:0;top:0;`</span><span class="hljs-built_in">this</span>.root.appendChild(canvas);<span class="hljs-comment">// 相等时画线</span><span class="hljs-keyword">const</span> ctx  = canvas.getContext(<span class="hljs-string">&quot;2d&quot;</span>);ctx.strokeStyle = <span class="hljs-built_in">this</span>.defaultCanvasLineColor;ctx.lineWidth = <span class="hljs-built_in">this</span>.defaultCanvasLineWidth;<span class="hljs-keyword">const</span> &#123; left = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span> &#125; = <span class="hljs-built_in">this</span>.rootPosition;ctx.beginPath();ctx.moveTo(x - left, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 注意：此时的移动的位置相对于根元素，也就是我们展示区域</span>ctx.lineTo(x - left, height);ctx.stroke();<span class="hljs-comment">// 清除画布</span><span class="hljs-keyword">const</span> &#123; width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span> &#125; = <span class="hljs-built_in">this</span>.rootPosition;ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);</code></pre><h3 id="7-如何将元素放到拖拽的位置？"><a href="#7-如何将元素放到拖拽的位置？" class="headerlink" title="7. 如何将元素放到拖拽的位置？"></a>7. 如何将元素放到拖拽的位置？</h3><p>​    知道了拖拽的时候位置，我们可以在dragEnd的时候将元素的样式的位置改为落点位置，这样就可以了，具体根据业务不同再细微调整。</p><p>   <strong>注意：  如果落点有父子关系的话，落点位置要相对于父节点的位移，而非相对于视口！</strong></p><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>   拖拽对齐参考线是一项很常见功能，也是很耗费性能的操作，所以应保持在拖拽过程中尽可能地节省开销。 比如我们在监听dragMove的事件的时候，如果我们的鼠标位置在原地不动，它还是会一直执行，我们可以存储上一次的鼠标位置和这次的对比，如果完全一样就没必要执行里面的逻辑，这样可以节省不必要的开销。另一方面就是我们可以通过对dragMove函数进行节流处理，降低单位时间执行的次数，这样也能大大提高性能。总之，拖拽是门手艺，学会需要勇气，一起来试试吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON.stringify和JSON.parse</title>
    <link href="/blog/2020/12/21/JSON.stringify%E5%92%8CJSON.parse/"/>
    <url>/blog/2020/12/21/JSON.stringify%E5%92%8CJSON.parse/</url>
    
    <content type="html"><![CDATA[<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON的全称是<code>JavaScript Object Notation</code>，意思是JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式</p><h5 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h5><p>JSON 有两种表示法， 对象和数组，两种表示法可以相互嵌套组合， 和 JavaScript 中的语法基本一致， 但有一些必须遵守的格式</p><ul><li>关键字必须是字符串， 值可以是字符串、 数值、 Boolean、null、 对象或数组</li><li>字符串必须用双引号括起来</li><li>JSON 中不可以有注释</li></ul><p>javaScript 中提供了两个处理 JSON 的方法， 分别是</p><p><code>JSON.stringify</code>: 将对象处理成 JSON字符串</p><p><code>JSON.parse</code>: 将 JSON 字符串转化成对象</p><p>这两个方法平时开发中使用率还是很高的， 比如将对象转为字符串存入 <code>storage</code>,  或者深度复制一个对象</p><p>通常用法如下</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xiaoming = &#123;    name: <span class="hljs-string">&#x27;小明&#x27;</span>,    age: <span class="hljs-number">14</span>,    skills: [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Lisp&#x27;</span>]&#125;;<span class="hljs-keyword">const</span> s = <span class="hljs-built_in">JSON</span>.stringify(xiaoming);<span class="hljs-built_in">console</span>.log(s)<span class="hljs-comment">// &#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;]&#125;&#x27;</span><span class="hljs-keyword">const</span> so = <span class="hljs-built_in">JSON</span>.parse(s);<span class="hljs-built_in">console</span>.log(so);<span class="hljs-comment">/*</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">    name: &#x27;小明&#x27;,</span><span class="hljs-comment">    age: 14,</span><span class="hljs-comment">    skills: [&#x27;JavaScript&#x27;, &#x27;Java&#x27;, &#x27;Python&#x27;, &#x27;Lisp&#x27;]</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span></code></pre><p>但是这两个方法并非这么简单， 我们平时使用过程中很容易忽略了它的高级用法， 我们一个一个的看</p><h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h4><p>先开看看它的语法</p><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(value[, replacer [, space]])</code></pre><p>是的， 你没看错，是不是很惊讶， 它居然有三个参数，如果你知道这个知识点， 那么你可以不用往下看了， 你很棒！</p><p>那么我们看看这三个参数到底是干什么， 它到底有何神通？</p><ul><li>value: 这个我们一直在用， 没什么可介绍的， 它就是我们要转化成 JSON 字符串的对象</li><li>replacer: 可选值， 函数或者数组， 用于序列化过程中， 处理每个属性</li><li>space: 可选值 字符串或者数字， 用于美化输出</li></ul><p>光看文字说明可能不大容易理解， 我们举几个🌰</p><pre><code class="hljs javascript"><span class="hljs-comment">// 我们的目标对象</span><span class="hljs-keyword">const</span> xiaoming = &#123;    name: <span class="hljs-string">&#x27;小明&#x27;</span>,    age: <span class="hljs-number">14</span>,    skills: [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Lisp&#x27;</span>],  friends: [&#123;<span class="hljs-attr">names</span>: <span class="hljs-string">&#x27;xiaohong&#x27;</span>&#125;]&#125;;</code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 第二个参数是数组</span><span class="hljs-keyword">const</span> temp1 = <span class="hljs-built_in">JSON</span>.stringify(xiaoming, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;friends&#x27;</span>]);<span class="hljs-built_in">console</span>.log(temp1);<span class="hljs-comment">// &#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;friends&quot;:[&#123;&#125;]&#125;&#x27;</span></code></pre><p>发现了什么， 得到的 JSON 字符串 temp1 的属性值是经过第二个参数数组过滤后的， 而且第二数组的属性平铺的， 不考虑目标对象的深度，如果第二个参数是<code> [&#39;name&#39;, &#39;age&#39;, &#39;friends&#39;, &#39;names&#39;]</code>, 那么最终得到的值就是 <code>&#39;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;friends&quot;:[&#123;&quot;names&quot;: &quot;xiaohong&quot;&#125;]&#125;&#39;</code></p><pre><code class="hljs javascript"><span class="hljs-comment">// 第二个参数是函数</span><span class="hljs-keyword">const</span> temp2 = <span class="hljs-built_in">JSON</span>.stringify(xiaoming, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, v</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(k, v); <span class="hljs-keyword">return</span> v; &#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------------------------分割线&#x27;</span>)<span class="hljs-built_in">console</span>.log(temp2);<span class="hljs-comment">/**</span><span class="hljs-comment">&quot;&quot; &#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;],&quot;friends&quot;:[&#123;&quot;names&quot;:&quot;xiaohong&quot;&#125;]&#125;&#x27;</span><span class="hljs-comment">name 小明</span><span class="hljs-comment">age 14</span><span class="hljs-comment">skills [&quot;JavaScript&quot;, &quot;Java&quot;, &quot;Python&quot;, &quot;Lisp&quot;]</span><span class="hljs-comment">0 JavaScript</span><span class="hljs-comment">1 Java</span><span class="hljs-comment">2 Python</span><span class="hljs-comment">3 Lisp</span><span class="hljs-comment">friends [&#123;names: &quot;xiaohong&quot;&#125;]</span><span class="hljs-comment">0 &#123;names: &quot;xiaohong&quot;&#125;</span><span class="hljs-comment">names xiaohong</span><span class="hljs-comment">---------------------------------------分割线</span><span class="hljs-comment">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;],&quot;friends&quot;:[&#123;&quot;names&quot;:&quot;xiaohong&quot;&#125;]&#125;&#x27;</span><span class="hljs-comment">*/</span></code></pre><p>分割线以上即第二个参数打印出来的， 对象的每个属性都会递归的去调用这个函数， 函数有两个参数， 第一个参数是 k, 代表对象的属性， 第二参数是 v，代表相应的属性值， 通过这个函数， 我们就可以对每个属性进行操作、过滤等。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 第三个参数是 字符串</span><span class="hljs-keyword">const</span> temp3 = <span class="hljs-built_in">JSON</span>.stringify(xiaoming, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;aaaa&#x27;</span>);<span class="hljs-built_in">console</span>.log(temp3);<span class="hljs-comment">/**</span><span class="hljs-comment">&quot;&#123;</span><span class="hljs-comment">aaaa&quot;name&quot;: &quot;小明&quot;,</span><span class="hljs-comment">aaaa&quot;age&quot;: 14,</span><span class="hljs-comment">aaaa&quot;skills&quot;: [</span><span class="hljs-comment">aaaaaaaa&quot;JavaScript&quot;,</span><span class="hljs-comment">aaaaaaaa&quot;Java&quot;,</span><span class="hljs-comment">aaaaaaaa&quot;Python&quot;,</span><span class="hljs-comment">aaaaaaaa&quot;Lisp&quot;</span><span class="hljs-comment">aaaa],</span><span class="hljs-comment">aaaa&quot;friends&quot;: [</span><span class="hljs-comment">aaaaaaaa&#123;</span><span class="hljs-comment">aaaaaaaaaaaa&quot;names&quot;: &quot;xiaohong&quot;</span><span class="hljs-comment">aaaaaaaa&#125;</span><span class="hljs-comment">aaaa]</span><span class="hljs-comment">&#125;&quot;</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 第三个参数是 数字</span><span class="hljs-keyword">const</span> temp4 = <span class="hljs-built_in">JSON</span>.stringify(xiaoming, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>);<span class="hljs-built_in">console</span>.log(temp4);<span class="hljs-comment">/**</span><span class="hljs-comment">&quot;&#123;</span><span class="hljs-comment">    &quot;name&quot;: &quot;小明&quot;,</span><span class="hljs-comment">    &quot;age&quot;: 14,</span><span class="hljs-comment">    &quot;skills&quot;: [</span><span class="hljs-comment">        &quot;JavaScript&quot;,</span><span class="hljs-comment">        &quot;Java&quot;,</span><span class="hljs-comment">        &quot;Python&quot;,</span><span class="hljs-comment">        &quot;Lisp&quot;</span><span class="hljs-comment">    ],</span><span class="hljs-comment">    &quot;friends&quot;: [</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            &quot;names&quot;: &quot;xiaohong&quot;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">    ]</span><span class="hljs-comment">&#125;&quot;</span><span class="hljs-comment">*/</span></code></pre><p><code>JSON.stringify</code> 的第三个参数用于美化输出， 如果是字符串， 那么缩进的地方都会被字符串填满， 如 temp3 打印的那样。 如果是数字（num）， 那么缩进的地方都会被 num 个空格填满。</p><p><code>JSON.stringify</code> 的三个参数都介绍完了， 再介绍几个需要注意地方</p><ol><li><p><code>JSON.stringify</code> 不仅可以处理对象， 也可以处理其他类型</p><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">true</span>);                      <span class="hljs-comment">// &quot;true&quot;</span><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&quot;foo&quot;</span>);                     <span class="hljs-comment">// &quot;&quot;foo&quot;&quot;</span><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-number">1</span>);                         <span class="hljs-comment">// &quot;1&quot;</span><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">null</span>);                      <span class="hljs-comment">// &quot;null&quot;</span></code></pre></li><li><p>某些特定于 JavaScript 的对象属性会被 <code>JSON.stringify</code> 跳过</p><ul><li>函数属性（方法）</li><li>Symbol 类型的属性</li><li>存储 undefined 的属性</li><li>不可枚举的属性</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 被忽略</span>    alert(<span class="hljs-string">&quot;Hello&quot;</span>);  &#125;,  [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>)]: <span class="hljs-number">123</span>, <span class="hljs-comment">// 被忽略</span>  something: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 被忽略</span>  ...Object.create(        <span class="hljs-literal">null</span>,         &#123;             x: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// 被忽略</span>        &#125;    )&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(user)); <span class="hljs-comment">// &#123;&#125;</span></code></pre></li><li><p><code>JSON.stringify</code>第二个参数<code>replacer</code>如果是函数的话， 会根据对象的键值对递归的去调用， 但是第一个调用很特别，  <code>(key, value)</code> 对的键是空的， 并且该值是整个目标对象。 这个理念是为了给 <code>replacer</code> 提供尽可能多的功能： 如果有必要， 它有机会分析并替换、跳过整个对象</p></li><li><p><code>JSON.stringify</code> 转换的对象中不可以有循环引用</p></li></ol><h5 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON 方法"></a>toJSON 方法</h5><p>像<code>toStirng</code>进行字符串转换， 对象也可以提供 <code>toJSON</code> 方法来进行 JSON 转换。如果可用，<code>JSON.stringify</code> 会自动调用它</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> meetup = &#123;  title: <span class="hljs-string">&quot;Conference&quot;</span>,  date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.UTC(<span class="hljs-number">2020</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)),&#125;;alert( <span class="hljs-built_in">JSON</span>.stringify(meetup) );<span class="hljs-comment">/*</span><span class="hljs-comment">  &#123;</span><span class="hljs-comment">    &quot;title&quot;:&quot;Conference&quot;,</span><span class="hljs-comment">    &quot;date&quot;:&quot;2020-01-01T00:00:00.000Z&quot;,  // (1)</span><span class="hljs-comment">  &#125;</span><span class="hljs-comment">*/</span></code></pre><p>在这儿我们可以看到 <code>date</code>  变成了一个字符串。这是因为所有日期都有一个内置的 <code>toJSON</code> 方法来返回这种类型的字符串</p><p>我们也可以为对象 xiaoming 添加一个自定义的 <code>toJSON</code>, (xiaoming 今天的出场率有点高呀， ^_^)</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xiaoming = &#123;    name: <span class="hljs-string">&#x27;小明&#x27;</span>,    age: <span class="hljs-number">14</span>,    skills: [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Lisp&#x27;</span>],    <span class="hljs-function"><span class="hljs-title">toJSON</span>(<span class="hljs-params"></span>)</span> &#123;      <span class="hljs-keyword">return</span> &#123;        ...this,        hobby: <span class="hljs-string">&#x27;读书&#x27;</span>      &#125;;    &#125;&#125;;alert(<span class="hljs-built_in">JSON</span>.stringify(xiaoming));<span class="hljs-comment">// &#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;],&quot;hobby&quot;:&quot;读书&quot;&#125;&#x27;</span></code></pre><p>这样， 在返回的字符串中 xiaoming 就会多一个 <code>hobby: &#39;读书&#39;</code></p><h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h4><p>要解码 JSON 字符串， 我们需要另一个方法 <code>JSON.parse</code></p><p>语法</p><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.parse(str, [reviver]);</code></pre><ul><li><p>str</p><p>要解析的 JSON 字符串。</p></li><li><p>reviver</p><p>可选的函数 function(key,value)，该函数将为每个 <code>(key, value)</code> 对调用，并可以对值进行转换。</p></li></ul><p>基本用法如下</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;friends&quot;:[&#123;&quot;names&quot;:&quot;xiaohong&quot;&#125;]&#125;&#x27;</span>;xiaoming = <span class="hljs-built_in">JSON</span>.parse(xiaoming);alert(xiaoming.name);</code></pre><h5 id="使用-reviver"><a href="#使用-reviver" class="headerlink" title="使用 reviver"></a>使用 reviver</h5><p>假如我们拿到一个字符串， 他是这样的</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2020-11-30T12:00:00.000Z&quot;&#125;&#x27;</span>;</code></pre><p>现在我们需要对它进行反序列， 把它转换回 JavaScript 对象。</p><p>那么我们可以使用 <code>JSON.parse</code> 来完成</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2020-11-30T12:00:00.000Z&quot;&#125;&#x27;</span>;<span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">JSON</span>.parse(str);alert(obj.date.getDate()); <span class="hljs-comment">// Error: obj.date.getDate is not a function</span></code></pre><p>报错了， 转换以后的 date 字段是个字符串， 而不是 Date 对象。 那么我们要怎么做呢？</p><p>这是 <code>JSON.parse</code> 第二个参数 reviver 就派上用场了， 我们可以这么处理。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2020-11-30T12:00:00.000Z&quot;&#125;&#x27;</span>;<span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">JSON</span>.parse(str, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, v</span>) </span>&#123;  <span class="hljs-keyword">if</span> (k === <span class="hljs-string">&#x27;date&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(v);  &#125;  <span class="hljs-keyword">return</span> v;&#125;);alert(obj.date.getDate()); <span class="hljs-comment">// 30 </span></code></pre><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li><code>JSON.parse</code> 转换的字符串必须符合 JSON 格式， 否则会报错</li></ul><p><code>JSON.stringify</code> 和 <code>JSON.parse</code> 的用法就介绍完了， 那它们有什么用呢？ 举几个工作中用到的例子吧。</p><ol><li><p>将属性值中可以转成数字的字符串转成数字</p><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(  obj, <span class="hljs-comment">// 要转化的对象</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">key, value</span>) </span>&#123; <span class="hljs-comment">// 转换函数</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(value)) &#123; <span class="hljs-comment">// 判断是否可以转成数字</span>      <span class="hljs-keyword">return</span> +value; <span class="hljs-comment">// 那么返回转成数字的值</span>    &#125;    <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 否则返回原值</span>  &#125;,  <span class="hljs-number">4</span>);</code></pre></li><li><p>利用 <code>toJSON</code> 返回自己想要的对象， 属性顺序按自己的意愿排列</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  a: <span class="hljs-string">&#x27;1&#x27;</span>,  b: <span class="hljs-string">&#x27;2&#x27;</span>,  c: <span class="hljs-string">&#x27;3&#x27;</span>&#125;<span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&quot;toJSON&quot;</span>, &#123;  value: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123;      c: <span class="hljs-built_in">this</span>.c,      b: <span class="hljs-built_in">this</span>.b,      a: <span class="hljs-built_in">this</span>.a    &#125;;  &#125;,  configurable: <span class="hljs-literal">false</span>,  enumerable: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可枚举</span>  writable: <span class="hljs-literal">false</span>&#125;);<span class="hljs-built_in">JSON</span>.stringify(obj, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>);<span class="hljs-comment">// 输出的字符串就是 &#x27;&#123;&quot;c&quot;: &quot;3&quot;, &quot;b&quot;: &quot;2&quot;, &quot;a&quot;: &quot;1&quot;&#125;&#x27;</span></code></pre></li></ol><p>这里只是举了几个简单的例子，要想让这两个方法在工作中发挥出更大的作用， 还需要您自己亲自去使用， 去发掘。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中不识别自己封装的类型判断</title>
    <link href="/blog/2020/12/11/TS%E4%B8%AD%E4%B8%8D%E8%AF%86%E5%88%AB%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <url>/blog/2020/12/11/TS%E4%B8%AD%E4%B8%8D%E8%AF%86%E5%88%AB%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p>在大型项目中我们更愿意使用<code>ts</code>取代<code>js</code>，其中一个主要原因是<code>ts</code>能够进行静态类型检查，提高代码质量。</p><a id="more"></a><p>比如当我们对一个对象进行<code>push</code>操作时，<code>ts</code>会先判断当前对象是否是一个数组。就像这样：</p><p><img src="https://cdn.ljybill.com/uPic/image-20201211141434434.png" alt="image-20201211141434434"></p><p>这样能够比较安全的操作一些参数，然而我们可能进行一些类型校验的封装，比如下面的代码：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">arr</span>): <span class="hljs-title">boolean</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(arr);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span>(<span class="hljs-params">fn: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">boolean</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">&#x27;function&#x27;</span>;&#125;</code></pre><p>然而，如果这样封装之后，<code>ts</code>并不买账你的类型判断：</p><p><img src="https://cdn.ljybill.com/uPic/image-20201211141925858.png" alt="image-20201211141925858"></p><p>这种情况下怎么办呢？</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有两种解决方案：</p><ol><li>一种是强行断言</li></ol><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; | <span class="hljs-literal">undefined</span></span>) </span>&#123;    arg.push(<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (isArray(arg)) &#123;        (arg <span class="hljs-keyword">as</span> <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;).push(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arg)) &#123;        arg.push(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p>这并不是一种优雅的选择。</p><ol start="2"><li><strong>修改<code>isFunction</code>等判断类型函数的返回值</strong></li></ol><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">arr</span>): <span class="hljs-title">arr</span> <span class="hljs-title">is</span> <span class="hljs-title">Array</span>&lt;<span class="hljs-title">any</span>&gt; </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(arr);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span>(<span class="hljs-params">fn: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">fn</span> <span class="hljs-title">is</span> <span class="hljs-title">Function</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">&#x27;function&#x27;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; | <span class="hljs-literal">undefined</span></span>) </span>&#123;    arg.push(<span class="hljs-number">1</span>);         <span class="hljs-comment">// TS2532: Object is possibly &#x27;undefined&#x27;.</span>    <span class="hljs-keyword">if</span> (isArray(arg)) &#123;        arg.push(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arg)) &#123;        arg.push(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p>至此，问题解决。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>但是ts默认是不校验<code>null</code>和<code>undefined</code>的。除非我们修改<code>ts.config.json</code>中的<code>strictNullChecks</code>字段。<code>&quot;strictNullChecks&quot;: true</code>。建议开启此配置项，能够进一步提高代码的严谨性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>踩坑记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>setTimeout和setInterval</title>
    <link href="/blog/2020/12/07/setTimeout%E5%92%8CsetInterval/"/>
    <url>/blog/2020/12/07/setTimeout%E5%92%8CsetInterval/</url>
    
    <content type="html"><![CDATA[<p>最近接到一个需求，开发一个倒计时组件，渲染后能够自动倒计时直到到达服务器下发的结束时间。纯展示类组件，暂时没有其他交互。</p><p>接到这个需求时，一开始是轻视的，但是在实现和测试阶段发现了很多问题，所以把倒计时相关的知识总结一下。</p><a id="more"></a><hr><p>以下列出文章所有的知识点，如果对介绍的内容已经掌握了，可以快速跳过</p><ol><li><a href="#%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><code>setTimeout</code>、<code>setInterval</code>基础知识（参数、含义）</a></li><li><a href="#Nested-setTimeout">嵌套调用<code>setTimeout</code>以达到setInterval效果</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">为什么一定要“清除定时器”</a></li><li><a href="#%E5%BB%B6%E4%BC%B8">延伸</a></li></ol><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p><code>const timerId = setTimeout(fun|code, [delay], [arg1], [arg2], ...)</code></p><ul><li><p><code>func|code</code></p><p>由于历史原因，传入字符串代码也是允许的，但是不建议这样做</p></li><li><p><code>delay</code></p><p>单位是ms，默认为0</p></li><li><p><code>arg1, arg2...</code></p><p>更多的参数，传递给参数1（参数1是一个函数）中的参数。IE9及以下不支持此参数</p></li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;  alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);&#125;<span class="hljs-built_in">setTimeout</span>(sayHi, <span class="hljs-number">1000</span>);<span class="hljs-comment">// 参数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi2</span>(<span class="hljs-params">name</span>) </span>&#123;  alert(<span class="hljs-string">`hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);&#125;<span class="hljs-built_in">setTimeout</span>(sayHi2, <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<span class="hljs-comment">// 字符串参数</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 不推荐</span><span class="hljs-comment">// 清除timeout</span><span class="hljs-keyword">const</span> timerId = <span class="hljs-built_in">setTimeout</span>(sayH1, <span class="hljs-number">1000</span>);<span class="hljs-keyword">const</span> oldTimerId = timerId;<span class="hljs-built_in">clearTimeout</span>(timerId);oldTimerId === timerId <span class="hljs-comment">// true</span></code></pre><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p><code>const timerId = setInterval(func | code, [delay], [arg1], [arg2], ...)</code></p><p>使用方式和<code>setTimeout()</code>差不多，不同的地方就是<code>setInterval()</code>方法创建的异步任务会无休止的执行下去，除非主动调用<code>clearInterval()</code></p><h2 id="Nested-setTimeout"><a href="#Nested-setTimeout" class="headerlink" title="Nested setTimeout"></a>Nested setTimeout</h2><p>综上，如果我们想要实现以一定频率反复执行一段代码，我们可以使用<code>setInterval</code>来实现。除此之外，我们还有另一个选择：嵌套执行<code>setTimeout</code>：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;tick&#x27;</span>);  <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// nested call</span>&#125;<span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">1000</span>)</code></pre><p>那么，这两种方式的区别是什么呢？</p><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(func, <span class="hljs-number">100</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;  func();  <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">100</span>);&#125;, <span class="hljs-number">100</span>)</code></pre><p><img src="https://cdn.ljybill.com/uPic/setTimeout%20setInterval.png" alt="setTimeout setInterval"></p><p>这个图能够直观表现两者的差异，<strong>在<code>setInterval</code>中，两个函数之间的实际间隔是小于100毫秒的</strong>，这是因为，<code>func</code>代码执行的时间“占用”掉了一部分间隔时间。</p><p>如果<code>func</code>执行时间过长（比如在这个例子中超过了100ms），那么当func执行完毕后，调度器会立即执行下一个<code>func</code>代码，这样就会无休止的执行下去。</p><p>如上图，<strong>Nested setTimeout就能够保证一个固定的时间</strong>，这是因为我们会在一个<code>func</code>的最后去生成一个新的定时器。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>嵌套调用setTimeout的优势就在于能够灵活地调整延迟时间来达到更“丝滑”的效果，下面就看下升级版的“Nested setTimeout”</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> delay = <span class="hljs-number">1000</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// do something</span>        count++;    <span class="hljs-keyword">const</span> offset = <span class="hljs-built_in">Date</span>.now() - (startTime + count * delay)    <span class="hljs-built_in">setTimeout</span>(tick, delay - offset)  &#125;, delay)&#125;</code></pre><h2 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h2><p>我们平时在写定时器的时候，一定会听过这样一句话：“一定要记得及时调用<code>clearTimeout/Interval</code>清除定时器”。那么为什么要及时清定时器，清的到底是什么？下面讲下关于<code>setTimeout</code>和<code>setInterval</code>的垃圾回收机制。</p><p>当我们给<code>setTimeout</code>/<code>setInterval</code>传递函数时，引擎会创建一个内部的引用，并在调度器（scheduler）中存起来，以防被垃圾回收所收集，哪怕外部并没有其他的引用。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 这个函数会被保留到内存中，直到函数被调用了，也就是说函数调用之后，垃圾回收就能够回收此函数了</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-number">100</span>);<span class="hljs-comment">// 这个函数会被保留到内存中，直到执行了clearInterval</span><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-number">100</span>);</code></pre><p>这里有个副作用，如果<code>function</code>中使用依赖了外部的词法环境（俗称闭包），那么这些外部的变量也会被保留到内存中。<strong>外部变量消耗的内存很可能比<code>function</code>本身消耗的内存多</strong>，这也是为什么我们常说清除定时器。</p><h2 id="为什么我的定时器会很慢"><a href="#为什么我的定时器会很慢" class="headerlink" title="为什么我的定时器会很慢"></a>为什么我的定时器会很慢</h2><p>请注意，不管是setTimeout还是setInterval都不保证精确的delay时间，并且在某些情况下，差距会很大，比如：</p><ul><li>CPU超载了</li><li>浏览器的标签页进入了background mode</li><li>设备进入节能模式（个人觉得也是限制了CPU的性能）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>方法<code>setTimeout(func, delay, ...args)</code>和<code>setInterval(func, delay, ...args)</code>能够一次或周期性地执行一个<code>function</code>在<code>delay</code>毫秒后</li><li>如果想取消计时器，我们可以调用<code>clearTimeout</code>/<code>clearInterval</code>，传递<code>setTimeout</code>/<code>setInterval</code>的返回值作为参数</li><li>嵌套执行<code>setTimeout</code>会比<code>setInterval</code>更灵活，能够及时调整<code>delay</code>到恰当的时间</li><li>记得及时清除计时器</li></ul><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>学习以下内容，能够更深入了解JS的定时器运行机制。</p><ul><li><p>微任务和宏任务</p></li><li><p>requestAnimationFrame</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello</title>
    <link href="/blog/2020/12/05/hello-world/"/>
    <url>/blog/2020/12/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>大家好</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

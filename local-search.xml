<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TS中不识别自己封装的类型判断</title>
    <link href="/blog/2020/12/11/TS%E4%B8%AD%E4%B8%8D%E8%AF%86%E5%88%AB%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <url>/blog/2020/12/11/TS%E4%B8%AD%E4%B8%8D%E8%AF%86%E5%88%AB%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p>在大型项目中我们更愿意使用<code>ts</code>取代<code>js</code>，其中一个主要原因是<code>ts</code>能够进行静态类型检查，提高代码质量。</p><a id="more"></a><p>比如当我们对一个对象进行<code>push</code>操作时，<code>ts</code>会先判断当前对象是否是一个数组。就像这样：</p><p><img src="https://cdn.ljybill.com/uPic/image-20201211141434434.png" alt="image-20201211141434434"></p><p>这样能够比较安全的操作一些参数，然而我们可能进行一些类型校验的封装，比如下面的代码：</p><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">arr</span>): <span class="hljs-title">boolean</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(arr);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span>(<span class="hljs-params">fn: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">boolean</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">&#x27;function&#x27;</span>;&#125;</code></pre><p>然而，如果这样封装之后，<code>ts</code>并不买账你的类型判断：</p><p><img src="https://cdn.ljybill.com/uPic/image-20201211141925858.png" alt="image-20201211141925858"></p><p>这种情况下怎么办呢？</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有两种解决方案：</p><ol><li>一种是强行断言</li></ol><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; | <span class="hljs-literal">undefined</span></span>) </span>&#123;    arg.push(<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (isArray(arg)) &#123;        (arg <span class="hljs-keyword">as</span> <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;).push(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arg)) &#123;        arg.push(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p>这并不是一种优雅的选择。</p><ol start="2"><li><strong>修改<code>isFunction</code>等判断类型函数的返回值</strong></li></ol><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">arr</span>): <span class="hljs-title">arr</span> <span class="hljs-title">is</span> <span class="hljs-title">Array</span>&lt;<span class="hljs-title">any</span>&gt; </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(arr);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span>(<span class="hljs-params">fn: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">fn</span> <span class="hljs-title">is</span> <span class="hljs-title">Function</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">&#x27;function&#x27;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; | <span class="hljs-literal">undefined</span></span>) </span>&#123;    arg.push(<span class="hljs-number">1</span>);         <span class="hljs-comment">// TS2532: Object is possibly &#x27;undefined&#x27;.</span>    <span class="hljs-keyword">if</span> (isArray(arg)) &#123;        arg.push(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arg)) &#123;        arg.push(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p>至此，问题解决。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>但是ts默认是不校验<code>null</code>和<code>undefined</code>的。除非我们修改<code>ts.config.json</code>中的<code>strictNullChecks</code>字段。<code>&quot;strictNullChecks&quot;: true</code>。建议开启此配置项，能够进一步提高代码的严谨性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>踩坑记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>setTimeout和setInterval</title>
    <link href="/blog/2020/12/07/setTimeout%E5%92%8CsetInterval/"/>
    <url>/blog/2020/12/07/setTimeout%E5%92%8CsetInterval/</url>
    
    <content type="html"><![CDATA[<p>最近接到一个需求，开发一个倒计时组件，渲染后能够自动倒计时直到到达服务器下发的结束时间。纯展示类组件，暂时没有其他交互。</p><p>接到这个需求时，一开始是轻视的，但是在实现和测试阶段发现了很多问题，所以把倒计时相关的知识总结一下。</p><a id="more"></a><hr><p>以下列出文章所有的知识点，如果对介绍的内容已经掌握了，可以快速跳过</p><ol><li><a href="#%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><code>setTimeout</code>、<code>setInterval</code>基础知识（参数、含义）</a></li><li><a href="#Nested-setTimeout">嵌套调用<code>setTimeout</code>以达到setInterval效果</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">为什么一定要“清除定时器”</a></li><li><a href="#%E5%BB%B6%E4%BC%B8">延伸</a></li></ol><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p><code>const timerId = setTimeout(fun|code, [delay], [arg1], [arg2], ...)</code></p><ul><li><p><code>func|code</code></p><p>由于历史原因，传入字符串代码也是允许的，但是不建议这样做</p></li><li><p><code>delay</code></p><p>单位是ms，默认为0</p></li><li><p><code>arg1, arg2...</code></p><p>更多的参数，传递给参数1（参数1是一个函数）中的参数。IE9及以下不支持此参数</p></li></ul><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;  alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);&#125;<span class="hljs-built_in">setTimeout</span>(sayHi, <span class="hljs-number">1000</span>);<span class="hljs-comment">// 参数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi2</span>(<span class="hljs-params">name</span>) </span>&#123;  alert(<span class="hljs-string">`hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);&#125;<span class="hljs-built_in">setTimeout</span>(sayHi2, <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<span class="hljs-comment">// 字符串参数</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 不推荐</span><span class="hljs-comment">// 清除timeout</span><span class="hljs-keyword">const</span> timerId = <span class="hljs-built_in">setTimeout</span>(sayH1, <span class="hljs-number">1000</span>);<span class="hljs-keyword">const</span> oldTimerId = timerId;<span class="hljs-built_in">clearTimeout</span>(timerId);oldTimerId === timerId <span class="hljs-comment">// true</span></code></pre><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p><code>const timerId = setInterval(func | code, [delay], [arg1], [arg2], ...)</code></p><p>使用方式和<code>setTimeout()</code>差不多，不同的地方就是<code>setInterval()</code>方法创建的异步任务会无休止的执行下去，除非主动调用<code>clearInterval()</code></p><h2 id="Nested-setTimeout"><a href="#Nested-setTimeout" class="headerlink" title="Nested setTimeout"></a>Nested setTimeout</h2><p>综上，如果我们想要实现以一定频率反复执行一段代码，我们可以使用<code>setInterval</code>来实现。除此之外，我们还有另一个选择：嵌套执行<code>setTimeout</code>：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;tick&#x27;</span>);  <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// nested call</span>&#125;<span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">1000</span>)</code></pre><p>那么，这两种方式的区别是什么呢？</p><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(func, <span class="hljs-number">100</span>)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;  func();  <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">100</span>);&#125;, <span class="hljs-number">100</span>)</code></pre><p><img src="https://cdn.ljybill.com/uPic/setTimeout%20setInterval.png" alt="setTimeout setInterval"></p><p>这个图能够直观表现两者的差异，<strong>在<code>setInterval</code>中，两个函数之间的实际间隔是小于100毫秒的</strong>，这是因为，<code>func</code>代码执行的时间“占用”掉了一部分间隔时间。</p><p>如果<code>func</code>执行时间过长（比如在这个例子中超过了100ms），那么当func执行完毕后，调度器会立即执行下一个<code>func</code>代码，这样就会无休止的执行下去。</p><p>如上图，<strong>Nested setTimeout就能够保证一个固定的时间</strong>，这是因为我们会在一个<code>func</code>的最后去生成一个新的定时器。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>嵌套调用setTimeout的优势就在于能够灵活地调整延迟时间来达到更“丝滑”的效果，下面就看下升级版的“Nested setTimeout”</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> delay = <span class="hljs-number">1000</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// do something</span>        count++;    <span class="hljs-keyword">const</span> offset = <span class="hljs-built_in">Date</span>.now() - (startTime + count * delay)    <span class="hljs-built_in">setTimeout</span>(tick, delay - offset)  &#125;, delay)&#125;</code></pre><h2 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h2><p>我们平时在写定时器的时候，一定会听过这样一句话：“一定要记得及时调用<code>clearTimeout/Interval</code>清除定时器”。那么为什么要及时清定时器，清的到底是什么？下面讲下关于<code>setTimeout</code>和<code>setInterval</code>的垃圾回收机制。</p><p>当我们给<code>setTimeout</code>/<code>setInterval</code>传递函数时，引擎会创建一个内部的引用，并在调度器（scheduler）中存起来，以防被垃圾回收所收集，哪怕外部并没有其他的引用。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 这个函数会被保留到内存中，直到函数被调用了，也就是说函数调用之后，垃圾回收就能够回收此函数了</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-number">100</span>);<span class="hljs-comment">// 这个函数会被保留到内存中，直到执行了clearInterval</span><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-number">100</span>);</code></pre><p>这里有个副作用，如果<code>function</code>中使用依赖了外部的词法环境（俗称闭包），那么这些外部的变量也会被保留到内存中。<strong>外部变量消耗的内存很可能比<code>function</code>本身消耗的内存多</strong>，这也是为什么我们常说清除定时器。</p><h2 id="为什么我的定时器会很慢"><a href="#为什么我的定时器会很慢" class="headerlink" title="为什么我的定时器会很慢"></a>为什么我的定时器会很慢</h2><p>请注意，不管是setTimeout还是setInterval都不保证精确的delay时间，并且在某些情况下，差距会很大，比如：</p><ul><li>CPU超载了</li><li>浏览器的标签页进入了background mode</li><li>设备进入节能模式（个人觉得也是限制了CPU的性能）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>方法<code>setTimeout(func, delay, ...args)</code>和<code>setInterval(func, delay, ...args)</code>能够一次或周期性地执行一个<code>function</code>在<code>delay</code>毫秒后</li><li>如果想取消计时器，我们可以调用<code>clearTimeout</code>/<code>clearInterval</code>，传递<code>setTimeout</code>/<code>setInterval</code>的返回值作为参数</li><li>嵌套执行<code>setTimeout</code>会比<code>setInterval</code>更灵活，能够及时调整<code>delay</code>到恰当的时间</li><li>记得及时清除计时器</li></ul><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>学习以下内容，能够更深入了解JS的定时器运行机制。</p><ul><li><p>微任务和宏任务</p></li><li><p>requestAnimationFrame</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello</title>
    <link href="/blog/2020/12/05/hello-world/"/>
    <url>/blog/2020/12/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>大家好</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

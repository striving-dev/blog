<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>setTimeout和setInterval</title>
    <link href="/blog/2020/12/07/setTimeout%E5%92%8CsetInterval/"/>
    <url>/blog/2020/12/07/setTimeout%E5%92%8CsetInterval/</url>
    
    <content type="html"><![CDATA[<p>最近接到一个需求，开发一个倒计时组件，渲染后能够自动倒计时直到到达服务器下发的结束时间。纯展示类组件，暂时没有其他交互。</p><p>接到这个需求时，一开始是轻视的，但是在实现和测试阶段发现了很多问题，所以把倒计时相关的知识总结一下。</p><a id="more"></a><hr><p>以下列出文章所有的知识点，如果对介绍的内容已经掌握了，可以快速跳过</p><ol><li><a href="#%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><code>setTimeout</code>、<code>setInterval</code>基础知识（参数、含义）</a></li><li><a href="#Nested-setTimeout">嵌套调用<code>setTimeout</code>以达到setInterval效果</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">为什么一定要“清除定时器”</a></li><li><a href="#%E5%BB%B6%E4%BC%B8">延伸</a></li></ol><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p><code>const timerId = setTimeout(fun|code, [delay], [arg1], [arg2], ...)</code></p><ul><li><p><code>func|code</code></p><p>由于历史原因，传入字符串代码也是允许的，但是不建议这样做</p></li><li><p><code>delay</code></p><p>单位是ms，默认为0</p></li><li><p><code>arg1, arg2...</code></p><p>更多的参数，传递给参数1（参数1是一个函数）中的参数。IE9及以下不支持此参数</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(sayHi, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi2</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  alert(<span class="hljs-string">`hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(sayHi2, <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br><br><span class="hljs-comment">// 字符串参数</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 不推荐</span><br><br><span class="hljs-comment">// 清除timeout</span><br><span class="hljs-keyword">const</span> timerId = <span class="hljs-built_in">setTimeout</span>(sayH1, <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">const</span> oldTimerId = timerId;<br><span class="hljs-built_in">clearTimeout</span>(timerId);<br>oldTimerId === timerId <span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;<br>  alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(sayHi, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi2</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  alert(<span class="hljs-string">`hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(sayHi2, <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br><br><span class="hljs-comment">// 字符串参数</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 不推荐</span><br><br><span class="hljs-comment">// 清除timeout</span><br><span class="hljs-keyword">const</span> timerId = <span class="hljs-built_in">setTimeout</span>(sayH1, <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">const</span> oldTimerId = timerId;<br><span class="hljs-built_in">clearTimeout</span>(timerId);<br>oldTimerId === timerId <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p><code>const timerId = setInterval(func | code, [delay], [arg1], [arg2], ...)</code></p><p>使用方式和<code>setTimeout()</code>差不多，不同的地方就是<code>setInterval()</code>方法创建的异步任务会无休止的执行下去，除非主动调用<code>clearInterval()</code></p><h2 id="Nested-setTimeout"><a href="#Nested-setTimeout" class="headerlink" title="Nested setTimeout"></a>Nested setTimeout</h2><p>综上，如果我们想要实现以一定频率反复执行一段代码，我们可以使用<code>setInterval</code>来实现。除此之外，我们还有另一个选择：嵌套执行<code>setTimeout</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;tick&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// nested call</span><br>&#125;<br><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;tick&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">1000</span>);  <span class="hljs-comment">// nested call</span><br>&#125;<br><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>那么，这两种方式的区别是什么呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><span class="hljs-built_in">setInterval</span>(func, <span class="hljs-number">100</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;<br>  func();<br>  <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">100</span>);<br>&#125;, <span class="hljs-number"><code class="language-hljs javascript"><span class="hljs-built_in">setInterval</span>(func, <span class="hljs-number">100</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;<br>  func();<br>  <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">100</span>);<br>&#125;, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.ljybill.com/uPic/setTimeout%20setInterval.png" alt="setTimeout setInterval"></p><p>这个图能够直观表现两者的差异，<strong>在<code>setInterval</code>中，两个函数之间的实际间隔是小于100毫秒的</strong>，这是因为，<code>func</code>代码执行的时间“占用”掉了一部分间隔时间。</p><p>如果<code>func</code>执行时间过长（比如在这个例子中超过了100ms），那么当func执行完毕后，调度器会立即执行下一个<code>func</code>代码，这样就会无休止的执行下去。</p><p>如上图，<strong>Nested setTimeout就能够保证一个固定的时间</strong>，这是因为我们会在一个<code>func</code>的最后去生成一个新的定时器。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>嵌套调用setTimeout的优势就在于能够灵活地调整延迟时间来达到更“丝滑”的效果，下面就看下升级版的“Nested setTimeout”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><span class="hljs-keyword">const</span> delay = <span class="hljs-number">1000</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// do something</span><br>    <br>    count++;<br>    <span class="hljs-keyword">const</span> offset = <span class="hljs-built_in">Date</span>.now() - (startTime + count * delay)<br>    <span class="hljs-built_in"><code class="language-hljs javascript"><span class="hljs-keyword">const</span> delay = <span class="hljs-number">1000</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// do something</span><br>    <br>    count++;<br>    <span class="hljs-keyword">const</span> offset = <span class="hljs-built_in">Date</span>.now() - (startTime + count * delay)<br>    <span class="hljs-built_in">setTimeout</span>(tick, delay - offset)<br>  &#125;, delay)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h2><p>我们平时在写定时器的时候，一定会听过这样一句话：“一定要记得及时调用<code>clearTimeout/Interval</code>清除定时器”。那么为什么要及时清定时器，清的到底是什么？下面讲下关于<code>setTimeout</code>和<code>setInterval</code>的垃圾回收机制。</p><p>当我们给<code>setTimeout</code>/<code>setInterval</code>传递函数时，引擎会创建一个内部的引用，并在调度器（scheduler）中存起来，以防被垃圾回收所收集，哪怕外部并没有其他的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><span class="hljs-comment">// 这个函数会被保留到内存中，直到函数被调用了，也就是说函数调用之后，垃圾回收就能够回收此函数了</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-number">100</span>);<br><br><span class="hljs-comment">// 这个函数会被保留到内存中，直到执行了clearInterval</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-number"><code class="language-hljs javascript"><span class="hljs-comment">// 这个函数会被保留到内存中，直到函数被调用了，也就是说函数调用之后，垃圾回收就能够回收此函数了</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-number">100</span>);<br><br><span class="hljs-comment">// 这个函数会被保留到内存中，直到执行了clearInterval</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;...&#125;, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>这里有个副作用，如果<code>function</code>中使用依赖了外部的词法环境（俗称闭包），那么这些外部的变量也会被保留到内存中。<strong>外部变量消耗的内存很可能比<code>function</code>本身消耗的内存多</strong>，这也是为什么我们常说清除定时器。</p><h2 id="为什么我的定时器会很慢"><a href="#为什么我的定时器会很慢" class="headerlink" title="为什么我的定时器会很慢"></a>为什么我的定时器会很慢</h2><p>请注意，不管是setTimeout还是setInterval都不保证精确的delay时间，并且在某些情况下，差距会很大，比如：</p><ul><li>CPU超载了</li><li>浏览器的标签页进入了background mode</li><li>设备进入节能模式（个人觉得也是限制了CPU的性能）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>方法<code>setTimeout(func, delay, ...args)</code>和<code>setInterval(func, delay, ...args)</code>能够一次或周期性地执行一个<code>function</code>在<code>delay</code>毫秒后</li><li>如果想取消计时器，我们可以调用<code>clearTimeout</code>/<code>clearInterval</code>，传递<code>setTimeout</code>/<code>setInterval</code>的返回值作为参数</li><li>嵌套执行<code>setTimeout</code>会比<code>setInterval</code>更灵活，能够及时调整<code>delay</code>到恰当的时间</li><li>记得及时清除计时器</li></ul><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>学习以下内容，能够更深入了解JS的定时器运行机制。</p><ul><li><p>微任务和宏任务</p></li><li><p>requestAnimationFrame</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JS基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello</title>
    <link href="/blog/2020/12/05/hello-world/"/>
    <url>/blog/2020/12/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>大家好</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
